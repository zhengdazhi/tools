# 规划程序结构

.
├── cmd
│   └── main.go
├── go.mod
├── go.sum
├── logutil
│   └── logutil.go
├── prometheus
│   └── prometheus.go
├── temperature
│   └── temperature.go
└── tools

- cmd/maing.go:程序入口，用来设置程序启动参数等
- prometheus/prometheus.go:定义prometheus数据格式和启动promethes的http监听
- temperature：根据系统平台收集cpu温度
- tools：存放不同平台的cpu温度收集工具
- logutil：定义日志

## main文件

cmd/main.go

```go
package main

import (
	"flag"
	"fmt"
	"prome_cpu_temperature/logutil"
	"prome_cpu_temperature/prometheus"
)

func main() {
	var help bool
	var port string
	var debug bool

	flag.BoolVar(&help, "help", false, "show help imformation")
	flag.StringVar(&port, "port", "80", "port")
	flag.BoolVar(&debug, "debug", false, "enable debug mode")

	flag.Parse()

	// 启用或者禁用debug日志
	logutil.SetDebug(debug)

	switch {
	case help:
		flag.PrintDefaults()
	case port != "":
		fmt.Printf("port is %s \n", port)
		prometheus.Run(port)
	default:
		flag.PrintDefaults()
	}
}

```



## prometheus包

prometheus/prometheus.go

```go
package prometheus

import (
	"fmt"
	"log"
	"net/http"
	"os"
	"sync"
	"time"

	"prome_cpu_temperature/logutil"
	"prome_cpu_temperature/temperature"

	"github.com/prometheus/client_golang/prometheus"          // Prometheus客户端库
	"github.com/prometheus/client_golang/prometheus/promhttp" // Prometheus HTTP处理器
)

// 定义全局变量用于存储Prometheus指标
var (
	//prometheus.NewGauge 是 Prometheus 客户端库中的一个函数，用于创建一个新的 Gauge 指标。
	//Gauge 是一种指标类型，可以表示一个瞬时值，它可以增加、减少或设置到任意值，适合用于表示当前状态，比如温度、内存使用、当前连接数等。
	cpuCoreCount = prometheus.NewGauge(prometheus.GaugeOpts{
		// prometheus.GaugeOpts 是一个结构体，用于配置 Gauge 指标的各种属性。
		// 该结构体包含多个字段，如 Name（指标名称）、Help（指标帮助信息）等。
		Name: "cpu_core_count",
		Help: "Number of CPU cores",
	})
	cpuCoreTemperatureMax = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "cpu_core_temperature_max",
		Help: "Maximum temperature of all CPU cores",
	})
	cpuCoreTemperatureMin = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "cpu_core_temperature_min",
		Help: "Minimum temperature of all CPU cores",
	})
	cpuCoreTemperatureAvg = prometheus.NewGauge(prometheus.GaugeOpts{
		Name: "cpu_core_temperature_avg",
		Help: "Average temperature of all CPU cores",
	})
)

// 定义结构体用于存储CPU指标数据
type cpuMetrics struct {
	cpuCoreCount          int     // CPU核心数量
	cpuCoreTemperatureMax float64 // 所有CPU核心的最高温度
	cpuCoreTemperatureMin float64 // 所有CPU核心的最低温度
	cpuCoreTemperatureAvg float64 // 所有CPU核心的平均温度
}

// 初始化注册Prometheus指标
func init() {
	// 使用 prometheus.MustRegister 函数将这个指标注册到 Prometheus 的默认注册表中
	prometheus.MustRegister(cpuCoreCount)
	prometheus.MustRegister(cpuCoreTemperatureMax)
	prometheus.MustRegister(cpuCoreTemperatureMin)
	prometheus.MustRegister(cpuCoreTemperatureAvg)
}

// 启动主程序
func Run(port string) {
	var wg sync.WaitGroup
	wg.Add(2)
	// 启动http服务
	go func() {
		defer wg.Done()
		startHttp(port)
	}()
	// 收集更新数据
	go func() {
		defer wg.Done()
		err := collectAndSetMetrics()
		if err != nil {
			fmt.Printf("Error collecting metrics: %v\n", err)
			os.Exit(1)
		}
	}()
	wg.Wait()
}

// 启动prometheus http服务
func startHttp(port string) {
	httpAddr := ":" + port
	http.Handle("/metrics", promhttp.Handler())
	log.Printf("Starting HTTP server on %s", httpAddr)
	//logutil.LogDebug("Start HTTP server on %s", httpAddr)
	log.Fatal(http.ListenAndServe(httpAddr, nil))
}

// 收集并设置CPU指标
func collectAndSetMetrics() error {
	// 死循环不断更新数据
		cpuData, err := temperature.GetCPUTemperature()
		if err != nil {
			fmt.Printf("Error: %T", err)
			os.Exit(1)
		}
	for {
		// 模拟数据，这里应该用实际从temperature包获取的数据
		cpuData := temperature.CPUData{
			CPUCores:       4,
			MaxTemperature: 75.0,
			MinTemperature: 35.0,
			AvgTemperature: 55.0,
		}

		// 设置Prometheus指标值
		cpuCoreCount.Set(float64(cpuData.CPUCores))
		cpuCoreTemperatureMax.Set(cpuData.MaxTemperature)
		cpuCoreTemperatureMin.Set(cpuData.MinTemperature)
		cpuCoreTemperatureAvg.Set(cpuData.AvgTemperature)
		logutil.LogDebug("Collected CPU metrics: cores=%d, max=%.2f, min=%.2f, avg=%.2f",
			cpuData.CPUCores,
			cpuData.MaxTemperature,
			cpuData.MinTemperature,
			cpuData.AvgTemperature,
		)

		time.Sleep(10 * time.Second)
	}

}

```



## temperature包

temperature/temperature.go

```go
package temperature

import (
	"fmt"
	"prome_cpu_temperature/logutil"
	"runtime"
	"time"
)

// CPUData 用于存储CPU温度数据
type CPUData struct {
	CPUCores       int
	MaxTemperature float64
	MinTemperature float64
	AvgTemperature float64
}

// 定义一个接口获取cpu温度
type CPUTemperatureGetter interface {
	FetchCPUTemperature() (*CPUData, error)
}

// 工厂函数，根据系统类型返回对应的CPUTemperatureGetter实现
func NewCPUTemperatureGetter() (CPUTemperatureGetter, error) {
	// 根据不同的系统架构返回对应的底层实现
	switch runtime.GOOS {
	case "windows":
		return WindowsTemperatureGetter{}, nil
	case "linux":
		return LinuxTemperatureGetter{}, nil
	default:
		return nil, fmt.Errorf("unsupported opeaating system %s", runtime.GOOS)
	}
}

// 封装一个函数让外部调用
func GetCPUTemperature() (*CPUData, error) {
	// 创建收集器
	cpuTemperature, err := NewCPUTemperatureGetter()
	if err != nil {
		return nil, fmt.Errorf("error creating CPU temperature getter: %w", err)
	}
	logutil.LogDebug("创建收集器成")
	// 获取数据
	data, err := cpuTemperature.FetchCPUTemperature()
	if err != nil {
		return nil, fmt.Errorf("error getting CPU temperatue: %w", err)
	}
	logutil.LogDebug("收集数据完成")
	currentTime := time.Now()
	formatted := currentTime.Format("2006-01-02 15:04:05")
	fmt.Printf("######## %s ######\n", formatted)
	fmt.Printf("CPU Cores: %d\n", data.CPUCores)
	fmt.Printf("Max Temperature: %.2f°C\n", data.MaxTemperature)
	fmt.Printf("Min Temperature: %.2f°C\n", data.MinTemperature)
	fmt.Printf("Avg Temperature: %.2f°C\n", data.AvgTemperature)
	return data, nil
}

// linux 系统实现获取cpu温度接口
type LinuxTemperatureGetter struct {
}

// 实现temperature中的接口
func (l LinuxTemperatureGetter) FetchCPUTemperature() (*CPUData, error) {
	logutil.LogDebug("linux cpu temperature")

	// 以下是模拟数据，用来返回
	return &CPUData{
		CPUCores:       4,
		MaxTemperature: 75.0,
		MinTemperature: 35.0,
		AvgTemperature: 55.0,
	}, nil
}

// windows系统实现获取cpu温度接口
type WindowsTemperatureGetter struct {
}

func (w WindowsTemperatureGetter) FetchCPUTemperature() (*CPUData, error) {
	logutil.LogDebug("使用windows系统")

	// 以下是模拟数据，用来返回测试
	return &CPUData{
		CPUCores:       4,
		MaxTemperature: 75.0,
		MinTemperature: 35.0,
		AvgTemperature: 55.0,
	}, nil

}

```



## 添加环境检测工具

tools/OpenHardwareMonitor

windows下收集硬件数据的工具

## 日志功能

logutil/logutil.go

```go
package logutil

import (
	"log"
)

var debugMode bool

// SetDebug enables or disables debug mode
func SetDebug(debug bool) {
	debugMode = debug
}

// LogDebug logs debug messages if debug mode is enabled
func LogDebug(format string, v ...interface{}) {
	if debugMode {
		log.Printf(format, v...)
	}
}
```

# 实现windows系统的监控

temperature/windwos_temperature.go

```go
package temperature

import (
	"encoding/json"
	"fmt"
	"io"

	//"io/ioutil"
	"log"
	"net/http"
	"os/exec"
	"prome_cpu_temperature/logutil"
	"strconv"
	"strings"
)

// windows系统实现获取cpu温度接口
type WindowsTemperatureGetter struct {
}

// type TemperatureProbe struct {
// 	Name string
// 	//CurrentReading int32
// }

func (w WindowsTemperatureGetter) FetchCPUTemperature() (*CPUData, error) {
	logutil.LogDebug("使用windows系统")
	cpuData, err := openHardwareMonitorGetter()
	if err != nil {
		log.Println("获取温度数据失败\n", err)
		return nil, err
	}
	// 打印结果
	// fmt.Println("--------------------------------------------------")
	// fmt.Printf("CPU Cores: %d\n", cpuData.CPUCores)
	// fmt.Printf("Max Temperature: %.2f°C\n", cpuData.MaxTemperature)
	// fmt.Printf("Min Temperature: %.2f°C\n", cpuData.MinTemperature)
	// fmt.Printf("Avg Temperature: %.2f°C\n", cpuData.AvgTemperature)
	// fmt.Println("--------------------------------------------------")
	return &cpuData, err

	// 以下是模拟数据，用来返回测试
	// return &CPUData{
	// 	CPUCores:       4,
	// 	MaxTemperature: 75.0,
	// 	MinTemperature: 35.0,
	// 	AvgTemperature: 55.0,
	// }, nil

}

func wmicGetter() (string, error) {
	// 原始命令 wmic /namespace:\\root\wmi PATH MSAcpi_ThermalZoneTemperature get CurrentTemperature
	cmd := exec.Command("wmic", "/namespace:\\\\root\\wmi", "PATH", "MSAcpi_ThermalZoneTemperature", "get", "CurrentTemperature")
	out, err := cmd.StdoutPipe()
	if err != nil {
		log.Fatal(err)
		return "", err
	}

	// 启动命令
	err = cmd.Start()
	if err != nil {
		log.Fatal(err)
		return "", err
	}

	// 读取命令的输出
	data, err := io.ReadAll(out)
	if err != nil {
		log.Fatal(err)
		return "", err
	}

	// 等待命令完成
	err = cmd.Wait()
	if err != nil {
		log.Fatal(err)
		return "", err
	}

	// 将输出转换为字符串并去除多余的空白
	output := strings.TrimSpace(string(data))

	// 打印原始输出
	// fmt.Println("原始输出：\n", output)

	// 解析输出（假设输出包含标题和数据）
	lines := strings.Split(output, "\n")
	if len(lines) > 1 {
		// 从第二行获取温度数据
		temperatureRaw := strings.TrimSpace(lines[1])
		temperature := parseTemperature(temperatureRaw)
		fmt.Printf("windows当前温度：%.2f°C\n", temperature)
		return fmt.Sprintf("windows当前温度：%.2f°C\n", temperature), nil
	} else {
		fmt.Println("未找到温度数据")
		return "", err
	}

	//fmt.Println("windows cpu temperature")
}

// parseTemperature 将原始温度字符串转换为摄氏度的 float64 值
func parseTemperature(raw string) float64 {
	// 温度值以千分之一开尔文（K）为单位报告，转换为摄氏度
	// 转换公式是 (Temperature(K) - 273.15)
	// 例如：如果原始值是 3000，则表示 300.0K -> 27.85°C
	if temp, err := strconv.ParseFloat(raw, 64); err == nil {
		return (temp/10 - 273.15)
	}
	return 0
}

func openHardwareMonitorGetter() (CPUData, error) {
	logutil.LogDebug("使用openHardwareMonitor获取数据")
	// 假设 JSON 数据来自于本地文件或者 HTTP 请求
	url := "http://localhost:8085/data.json" // 修改为实际的 JSON 数据来源
	resp, err := http.Get(url)
	if err != nil {
		//log.Fatalf("Error fetching data: %v\n", err)
		return CPUData{}, err
	}
	defer resp.Body.Close()

	//body, err := ioutil.ReadAll(resp.Body)
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Error reading response: %v\n", err)
		return CPUData{}, err
	}

	var root Node
	if err := json.Unmarshal(body, &root); err != nil {
		//log.Fatalf("Error parsing JSON: %v\n", err)
		return CPUData{}, err
	}

	// 提取 CPU 温度信息
	var temperatures []float64
	extractCPUTemperatures(root, &temperatures)

	// 计算 CPU 温度统计数据
	cpuData := calculateWindowsCPUData(temperatures)
	// 打印结果
	// fmt.Println("--------------------------------------------------")
	// fmt.Printf("CPU Cores: %d\n", cpuData.CPUCores)
	// fmt.Printf("Max Temperature: %.2f°C\n", cpuData.MaxTemperature)
	// fmt.Printf("Min Temperature: %.2f°C\n", cpuData.MinTemperature)
	// fmt.Printf("Avg Temperature: %.2f°C\n", cpuData.AvgTemperature)
	// fmt.Println("--------------------------------------------------")
	return cpuData, nil
}

// 定义用于解析 JSON 的结构体
type Node struct {
	ID       int    `json:"id"`
	Text     string `json:"Text"`
	Min      string `json:"Min"`
	Value    string `json:"Value"`
	Max      string `json:"Max"`
	ImageURL string `json:"ImageURL"`
	Children []Node `json:"Children"`
}

// 递归遍历节点以提取 CPU 温度信息
func extractCPUTemperatures(node Node, temperatures *[]float64) {
	if node.Text == "Temperatures" {
		for _, child := range node.Children {
			//if strings.HasPrefix(child.Text, "CPU Core #") || child.Text == "CPU Package" {
			// 只收集cpu核心温度，不收集封装温度
			if strings.HasPrefix(child.Text, "CPU Core #") {
				if temp, err := strconv.ParseFloat(strings.TrimSuffix(child.Value, " °C"), 64); err == nil {
					*temperatures = append(*temperatures, temp)
				}
			}
		}
	}

	for _, child := range node.Children {
		extractCPUTemperatures(child, temperatures)
	}
}

// 计算 CPU 温度的统计数据
func calculateWindowsCPUData(temperatures []float64) CPUData {
	logutil.LogDebug("统计cpu多核平均温度")
	var data CPUData
	if len(temperatures) == 0 {
		return data
	}

	data.CPUCores = len(temperatures)
	sum := 0.0
	data.MinTemperature = temperatures[0]
	data.MaxTemperature = temperatures[0]

	for _, temp := range temperatures {
		if temp > data.MaxTemperature {
			data.MaxTemperature = temp
		}
		if temp < data.MinTemperature {
			data.MinTemperature = temp
		}
		sum += temp
	}

	data.AvgTemperature = sum / float64(data.CPUCores)
	return data
}

```

# 实现linux系统的监控

temperature/linux_temperature.go

```go
package temperature

import (
	"errors"
	"io"
	"log"
	"os/exec"
	"prome_cpu_temperature/logutil"
	"regexp"
	"strconv"
	"strings"
)

// linux 系统实现获取cpu温度接口
type LinuxTemperatureGetter struct {
}

// 实现temperature中的接口
func (l LinuxTemperatureGetter) FetchCPUTemperature() (*CPUData, error) {
	logutil.LogDebug("linux cpu temperature")
	// 采集原始数据
	cpu_tem, err := getCpuTem()
	// for _, line := range cpu_tem {
	// 	fmt.Println(line)
	// }
	if err != nil {
		return nil, err
	}
	// 统计温度数据
	cpuData, err := calculateLinuxCPUData(cpu_tem)
	if err != nil {
		return nil, err
	}
	return &cpuData, nil

	// 以下是模拟数据，用来返回
	// return &CPUData{
	// 	CPUCores:       4,
	// 	MaxTemperature: 75.0,
	// 	MinTemperature: 35.0,
	// 	AvgTemperature: 55.0,
	// }, nil
}

// 通过sensors命令获取cpu温度信息
func getCpuTem() ([]string, error) {
	logutil.LogDebug("使用sensors收集cpu温度数据")
	cmd := exec.Command("sensors")

	out, err := cmd.StdoutPipe()
	if err != nil {
		return nil, err
	}

	err = cmd.Start()
	if err != nil {
		return nil, err
	}

	data, err := io.ReadAll(out)
	if err != nil {
		return nil, err
	}

	err = cmd.Wait()
	if err != nil {
		return nil, err
	}

	//fmt.Println("temperature:\n", string(data))
	//cpu_data := string(data)
	cpu_data := strings.Split(string(data), "\n")
	return cpu_data, nil
}

// 收集cpu温度信息
func calculateLinuxCPUData(cpu_data []string) (CPUData, error) {
	var data CPUData
	// 定义正则匹配规则
	var temperatureRegex = regexp.MustCompile(`\+\d+\.\d+°C`)
	var tems []float64
	for _, line := range cpu_data {
		// 收集cpu 封装温度
		//if strings.HasPrefix(line, "Package id") {
		// 获取核心温度数据
		if strings.HasPrefix(line, "Core ") {
			//fmt.Println(line)
			match := temperatureRegex.FindString(line)
			if match != "" {
				temperatureStr := strings.TrimSuffix(strings.TrimPrefix(match, "+"), "°C") // 去除前缀和后缀，得到温度字符串
				//fmt.Println(temperatureStr)
				temperature, err := strconv.ParseFloat(temperatureStr, 64)
				if err != nil {
					log.Fatal("转换温度数据错误: ", err)
				}
				tems = append(tems, temperature)
			}
		}
	}
	// for _, tem := range tems {
	// 	fmt.Println(tem)
	// }
	if len(tems) == 0 {
		return data, errors.New("没有获得cpu核心温度数据")
	}
	// 获得cpu核心数
	data.CPUCores = len(tems)
	// 计算多个物理cpu的平均温度,和获取最大和最新温度
	sum := 0.0
	data.MinTemperature = tems[0]
	data.MaxTemperature = tems[0]
	for _, tem := range tems {
		if tem > data.MaxTemperature {
			data.MaxTemperature = tem
		}
		if tem < data.MinTemperature {
			data.MinTemperature = tem
		}
		sum += tem
	}
	data.AvgTemperature = sum / float64(data.CPUCores)
	return data, nil
}

```

# 判断系统环境工具准备

utils/utils.go

```go
package utils

import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"os"
	"os/exec"
	"path/filepath"
	"prome_cpu_temperature/logutil"
	"runtime"
	"time"
)

// 检测依赖工具是否配置齐全
func CheckTools() (bool, error) {
	switch runtime.GOOS {
	case "windows":
		logutil.LogDebug("Enviroment is Windows")
		return checkWindowsTools()
	case "linux":
		logutil.LogDebug("Enviroment is Linux")
		return checkLinuxTools()
	default:
		return false, fmt.Errorf("unsupported opeaating system %s", runtime.GOOS)
	}
}

// 检查Windows系统所需工具
func checkWindowsTools() (bool, error) {
	exe, err := os.Executable()
	if err != nil {
		return false, fmt.Errorf("error getting executable path: %w", err)
	}
	dir := filepath.Dir(exe)
	pwd, err := os.Getwd()
	if err != nil {
		return false, fmt.Errorf("error getting working directory: %w", err)
	}

	directories := []string{
		filepath.Join(dir, "tools", "OpenHardwareMonitor", "OpenHardwareMonitor.exe"),
		filepath.Join(pwd, "tools", "OpenHardwareMonitor", "OpenHardwareMonitor.exe"),
	}

	for _, filePath := range directories {
		if _, err := os.Stat(filePath); err == nil {
			logutil.LogDebug("Found OpenHardwareMonitor.exe at: ", filePath)
			// 开启OpenHardwareMonitor程序
			go runOpenHardwareMonitor(filePath)
			maxRetries := 10
			timeout := 1 * time.Second
			// 检测OpenHardwareMonitor是否正常开启
			err := checkOpenHardwareMonitor("http://127.0.0.1:8085/data.json", maxRetries, timeout)
			if err != nil {
				fmt.Printf("测试请求超时 %s \n", err)
				return false, err
			}
			return true, nil
		}
	}
	return false, errors.New("failed to find OpenHardwareMonitor.exe")
}

func runOpenHardwareMonitor(filePath string) {
	fmt.Printf("OpenHardwareMonitor dir: %s \n", filePath)
	cmd := exec.Command(filePath)
	err := cmd.Run()
	if err != nil {
		log.Fatal(err)
	}
}

// 判断OpenHardwareMonitor是否正常开启
func checkOpenHardwareMonitor(url string, maxRetries int, timeout time.Duration) error {
	fmt.Println("等待OpenHardwareMonitor开启")
	client := &http.Client{
		Timeout: timeout,
	}

	for i := 0; i < maxRetries; i++ {
		// 创建带有超时的上下文
		time.Sleep(timeout)
		fmt.Printf("请求 %d 次\n", i)
		ctx, cancel := context.WithTimeout(context.Background(), timeout)
		defer cancel()

		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			return fmt.Errorf("failed to create request: %v", err)
		}

		resp, err := client.Do(req)
		if err != nil {
			if os.IsTimeout(err) {
				fmt.Printf("Attempt %d: Request timed out after %v\n", i+1, timeout)
				continue
			} else {
				fmt.Errorf("attempt %d: failed to make request: %v", i+1, err)
				continue
			}
		}
		defer resp.Body.Close()

		if resp.StatusCode == http.StatusOK {
			fmt.Printf("Attempt %d: Request succeeded\n", i+1)
			return nil
		} else {
			fmt.Printf("Attempt %d: Request failed with status: %s\n", i+1, resp.Status)
		}
	}

	return errors.New("all attempts failed due to timeout")
}

// 检查Linux系统所需工具
func checkLinuxTools() (bool, error) {
	if info, err := os.Lstat("/usr/bin/sensors"); err == nil && !info.IsDir() {
		return true, nil
	}
	return false, errors.New("sensors tool not found")
}

```

在prometheus.go中的init函数中调用

```go
// 初始化注册Prometheus指标
func init() {
	// 使用 prometheus.MustRegister 函数将这个指标注册到 Prometheus 的默认注册表中
	prometheus.MustRegister(cpuCoreCount)
	prometheus.MustRegister(cpuCoreTemperatureMax)
	prometheus.MustRegister(cpuCoreTemperatureMin)
	prometheus.MustRegister(cpuCoreTemperatureAvg)
	// 检测底层监控工具是否存在
	ok, err := utils.CheckTools()
	if !ok {
		log.Fatalf("Required tools not found: %v", err)
	}
	fmt.Println("检测环境ok")
}
```

